# pbdecode

使用`protoc`工具解码的数据结构里面如果包含非`ascii`字符就会编码为八进制格式，也就是反斜杠`\`+3个数字，非常不方便阅读，`pbdecode`可以为了反解码八进制编码数据，支持文件、管道模式，非常高效。


> 管道模式
```
$ echo '\342\226\240\345\220\204\343\203\251\343\203\263\343\202\257\343\201\253\344\273\230\343\201\217\343\201\256\343\201\253\345\277\205\350\246\201\343\201\252\343\203\235\343\202\244\343\203\263\343\203\210\343\201\257\351\253\230\343\201\204\343\201\273\343\201\251\345\244\232\343\201\217\343\201\252\343\202\212\343\201\276\343\201\231\343\200\202\347\217\276\345\234\250\343\201\257\343\203\251\343\203\263\343\202\257\343\201\2146\343\201\244\343\201\253\345\210\206\343\201\221\343\202\211\343\202\214\343\201\246\343\201\204\343\201\276\343\201\231\343\200\202\346\234\200\351\253\230\343\203\251\343\203\263\343\202\257\343\201\257\343\202\255\343\203\263\343\202\260\343\201\247\343\201\231\343\200\202\n\342\226\240\345\220\204\343\203\251\343\203\263\343\202\257\343\201\253\343\201\257\344\270\213\344\275\215\343\203\251\343\203\263\343\202\257\343\201\214\350\250\255\343\201\221\343\202\211\343\202\214\343\201\246\343\201\204\343\201\276\343\201\231\343\200\202\347\267\217\350\250\210\343\201\24710\343\203\251\343\203\263\343\202\257\343\201\214\343\201\202\343\202\212\343\201\276\343\201\231\343\200\202\344\270\213\344\275\215\343\203\251\343\203\263\343\202\2571\343\201\244\351\200\262\347\264\232\343\201\231\343\202\213\343\201\237\343\202\201\343\201\253\343\201\257\347\217\276\345\234\250\343\203\251\343\203\263\343\202\257\343\201\25610%\343\201\256\343\203\235\343\202\244\343\203\263\343\203\210\343\201\214\345\277\205\350\246\201\343\201\247\343\201\231\357\274\210\343\202\255\343\203\263\343\202\260\343\201\257500\343\203\235\343\202\244\343\203\263\343\203\210\357\274\211\343\200\202\n\342\226\240\343\203\251\343\203\263\343\202\257\347\242\272\345\256\232\346\210\246\343\201\247\343\200\201\343\203\251\343\203\263\343\202\257\343\201\257\343\200\214\350\254\216\343\201\256\346\243\213\345\243\253\343\200\215\343\201\214\350\241\250\347\244\272\343\201\225\343\202\214\343\201\276\343\201\231\343\200\202' | pbdecode
■各ランクに付くのに必要なポイントは高いほど多くなります。現在はランクが6つに分けられています。最高ランクはキングです。
■各ランクには下位ランクが設けられています。総計で10ランクがあります。下位ランク1つ進級するためには現在ランクの10%のポイントが必要です（キングは500ポイント）。
■ランク確定戦で、ランクは「謎の棋士」が表示されます
```
> 文件模式
```
$ pbdecode data.txt 
■各ランクに付くのに必要なポイントは高いほど多くなります。現在はランクが6つに分けられています。最高ランクはキングです。\n■各ランクには下位ランクが設けられています。総計で10ランクがあります。下位ランク1つ進級するためには現在ランクの10%のポイントが必要です（キングは500ポイント）。\n■ランク確定戦で、ランクは「謎の棋士」が表示されます
```

> 源码
```c++
//
//  main.cpp
//  pbdecode
//
//  Created by larryhou on 2019/12/7.
//  Copyright © 2019 larryhou. All rights reserved.
//

#include <assert.h>
#include <iostream>
#include <fstream>

void decode(const char *input, char *output, size_t length, bool newline = true)
{
    auto wCursor = output;
    
    auto rCursor = input;
    auto end = rCursor + length;
    while (rCursor < end)
    {
        *wCursor = *rCursor;
        if (*rCursor == '\\')
        {
            auto ptr = rCursor + 1;
            if (*ptr >= '0' && *ptr <= '9')
            {
                auto byte = 0;
                for (auto n = 0; n < 3; n++)
                {
                    byte = (byte << 3) | *ptr - '0';
                    ++ptr;
                }
                
                assert(byte <= 0xFF);
                *wCursor = static_cast<char>(byte);
                rCursor += 3;
            }
        }
        
        ++rCursor;
        ++wCursor;
    }
    
    *wCursor = 0;
    std::cout << output;
    if (newline) { std::cout << std::endl; }
    std::cout << std::flush;
}

void decode(const char *path)
{
    std::ifstream fs;
    fs.open(path, std::ifstream::binary);
    fs.seekg(0, std::ios_base::end);
    auto length = static_cast<size_t>(fs.tellg());
    fs.seekg(0);
    
    char buffer[length];
    fs.read(buffer, length);
    fs.close();
    
    decode(buffer, buffer, length, false);
}

int main(int argc, const char * argv[])
{
    if (argc > 1)
    {
        for (auto i = 1; i < argc; i++)
        {
            decode(argv[i]);
        }
    }
    else
    {
        std::string pipe;
        while (std::getline(std::cin, pipe))
        {
            auto size = pipe.size();
            
            char buffer[size];
            decode(pipe.c_str(), buffer, size);
        }
    }
    
    return 0;
}
```